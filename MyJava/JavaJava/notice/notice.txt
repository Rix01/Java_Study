- com.test << 클래스 만들기, 메소드 호출해 보기 >>

- com.sec01 << 기본 자료형, 값 >>

- com.sec03	클래스 선언, 생성, 멤버 호출
class - userDataType : 자주 사용하는 변수와 메소드를 하나의 이름으로 등록해서
					   필요할 때마다 생성해서 사용하는 것
	  - 선언된 멤버변수는 은닉(private)하고 오픈된 메소드(public)를 통해 
	  값 전달 및 변경(setter)하는 리턴하는 구조(getter)를 가진다.
	  - class 멤버 = 필드 + 메소드
	  
	  [선언방법]
	  	접근제한자 [abstract] class userName{
	  		필드 + 메소드
	  	}
	  	
ex) 정수 두 수를 관리하는 Test 클래스를 만들어보자.
class Test{
		private int a;
		private int b;
		
		// setter - void
		public void setA(int a){
			this.a = a;	// 전달 및 변경
		}
		public void setB(int b){
			this.b = b;
		}
		// getter - int
		public int getA(){
			return a;
		}
		public int getB(){
			return b;
		}
}

===================================================================
오버로딩 (Overloading) : 하나의 클래스 내에서 같은 이름의 메소드를 
						{매개변수 개수, 타입을 다르게} 여러 개 정의하는 것
		목적 : 같은 기능을 다양한 입력값에 적용
		
오버라이딩 (Overriding) : 상속시 부모 클래스의 메소드를 자식 클래스에서 
						{메소드명, 매개변수, 반환 타입을 동일} 재정의하는 것
		목적 : 부모 클래스의 동작을 자식 클래스에서 변경해서 기능에 사용
===================================================================		
- 생성자?
	- 클래스 이름과 동일하되 반환형은 없다.
	- 오버로드 할 수 있다.
	- 생성자는 객체를 생성할 때 단 한 번만 호출된다.
	- 메소드처럼 명시호출 할 수 없다.
	- 생성자는 상속되지 않으며, 객체를 생성할 때 단 한 번 호출된다.
	- 생성자를 명시하지 않으면 기본 생성자가 호출되고 명시하면 명시된 생성자가 호출된다.
	- 생성자는 멤버변수 초기화를 목적으로 한다.
===================================================================

com.sec11.myutil
    
제네릭스(Generics)는 컴파일 시 타입을 체크하고, 다양한 데이터 타입을 처리할 수 있도록 도와주는 기능
제네릭 클래스(Generic Class) : 특정 타입을 지정하지 않고, 여러 타입의 데이터를 저장할 수 있는 클래스
T를 사용해 다양한 타입을 받을 수 있다 
class Test<T> {}-제네릭 메서드(Generic Method) : 특정 메서드에서만 제네릭 타입을 적용하는 방법
                 public static <T> void print(T item) {
                           System.out.println(item);}
와일드카드(Generics Wildcard)  : 유연한  타입을 허용
           List<? extends T>    T와 T의 하위 클래스만 허용 (상한 제한)
           List<? super T>    T와 T의 상위 클래스만 허용 (하한 제한)

============================================================================
1) 람다식의 주요특징 
1. 익명 함수(Anonymous Function) 이름 없이 사용되는 함수로 함수형 인터페이스의 변수에 할당 가능.
2. 함수형 인터페이스 : 하나의 추상 메소드만을 가지는 인터페이를 말한다. -> @FunctionalInterface
3. 람다식은 단 하나의 추상 메소드만을 가지는 함수형 인터페이스에서만 사용 가능하다.(default,static 메소드는 여러 개 가질 수 있다.)
4. 간결한 코드 구조로 기존의 익명 클래스를 람다식을 사용하여 간단하게 표현할 수 있다.
5. 자바 컴파일러가 문맥을 보고 타입을 자동으로 추론한다.
6 .java.util.function 패키지에는 다양한 기본 함수형 인터페이스
(Function : 입력값을 받아서 가공한 후 다른 타입으로 변환하여 반환하는 인터페이스 R apply(T t), 
 Predicate: 입력값을 받아서 조건을 체크한 후 true 또는 false를 반환하는 인터페이스 boolean test(T t),
  Consumer :  입력값을 받아서 특정 작업을 수행하고 반환값이 없는 인터페이스 void accept(T t),
  Supplier : 입력값 없이 값을 생성하여 반환하는 인터페이스  T get())가 제공된다. 

[람다 표현식 ]
lambda 표현식은 익명으로 처리되어 이름이 없다.
lambda 표현식은 compiler 가 context 에 맞는 타입을 유추하기 때문에 return type이없다.
lambda 표현식은 compiler 가 context 에서 유추되어 throws clause 가 없다.)
lambda 표현식은 람다 표현식은 Generic 이 될 수 없어 type 파라미터를 선언할 수없다.

[형식] 
(int x, int y) -> { return x + y; }   // 기존 방식
(x, y) -> x + y   // 타입 생략 가능

case1 :  매개변수가 없는 경우
() -> System.out.println("Hello World!");

case2:  매개변수가 하나인 경우
x -> x * x;

case 3: 매개변수가 여러 개인 경우
(x, y) -> x + y;

case4  실행문이 여러 개일 경우
(x, y) -> {
    int sum = x + y;
    return sum;

  [다양한 형식]
  형식에 정의된 구문은 매개인자에 따라 괄호 () , 중괄호{}가 생략가능하다. 
 >> 매개인자로 su 을 받아 출력 하는 구문
    (int su) -> { System.out.println(su); }
 >>  자료형이 생략 가능하다.
 (su) -> { System.out.println(su); }
>>  매개인자 하나일경우 (), {}생략 가능하다
 su -> System.out.println(su);

>> 매개인자 없는 경우 빈 괄호()만 사용하여 명령 실행할 수 있다.
 ()->{ System.out.println('a')}

>> 매개인자 두 개 이상 이면 자료형 생략 하여 실행한다.
(a, b) -> { return a + b; }


>>매개인자 두 개이상이면 {}와 return 키워드를 생략해서 사용한다
(a, b) -> a + b;

==================================================================================
Stream API  데이터 집합을 효과적으로 처리할 수 있는 API로 필터링, 그룹핑등 가능하다. 

1) Stream 연산순서 
     (1)생성 :Collection.stream(), Stream.of(), Arrays.stream()
     (2)중간 연산 (Intermediate Operation):
        filter(), map(), sorted(), distinct(), limit(), flatMap() 등
        중간 연산은 스트림을 변환하는 작업을 수행하며, 최종 연산이 호출될 때 실행된다
     (3)최종 연산 (Terminal Operation)
       forEach(), collect(), reduce(), count(), sum(), min(), max() 등
        최종 연산이 수행되면 스트림이 소비되며, 이후에는 다시 사용할 수 없다

2)Stream 주요 연산
 map()    : 요소 변환
filter()     :조건에 맞는 요소만 선택
sorted()     : 정렬 수행
reduce()     : 누적 연산 수행
collect(): 리스트, 맵 등으로 변환

3.병렬 처리parallelStream()을 활용하면 데이터 병렬 처리가 가능하다

=========================================================================================
com.sec13.myio
https://docs.oracle.com/javase/tutorial/essential/io/index.html

java.io (기본 I/O)
스트림 기반: 데이터를 순차적인 스트림으로 처리.
블로킹 I/O: 읽기/쓰기 작업이 완료될 때까지 스레드가 대기합.
파일, 네트워크, 메모리 등 다양한 입출력 지원: 기본적인 파일 입출력, 네트워크 통신, 메모리 스트림 등을 처리.
단순하고 사용하기 쉬움: 기본적인 입출력 작업을 처리하는 데 적합.

java.nio (New I/O)
버퍼 기반: 데이터를 버퍼에 저장하고 처리한다.
논블로킹 I/O: 읽기/쓰기 작업이 완료되지 않아도 스레드가 다른 작업을 수행한다.
채널과 셀렉터: 채널을 통해 입출력을 수행하고, 셀렉터를 사용하여 여러 채널을 효율적으로 관리
고성능 I/O: 대규모 네트워크 애플리케이션 등 고성능 I/O가 필요한 경우에 적합하다. 

java.nio.file (NIO.2)
파일 시스템 API: 파일 및 디렉터리 작업을 위한 강력하고 유연한 API를 제공한다
Path 인터페이스: 파일 경로를 추상화하여 플랫폼 독립적인 코드를 작성할 수 있도록 한다. 
Files 클래스: 파일 복사, 이동, 삭제, 속성 관리 등 다양한 파일 시스템 작업을 지원한다.
파일 시스템 작업에 특화: 파일 시스템 관련 작업을 보다 쉽고 효율적으로 처리한다.

=======================================================================


















